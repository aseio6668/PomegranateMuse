"""
Rust code generator for Universal Code Modernization Platform
Generates idiomatic Rust code with modern patterns and best practices
"""

import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from language_targets import LanguageGenerator, LanguageFeatures, CodeGenerationContext, MigrationStrategy
from typing import Dict, List, Any
import json
from datetime import datetime


class RustGenerator(LanguageGenerator):
    """Generator for Rust programming language"""
    
    def __init__(self):
        features = LanguageFeatures(
            name="Rust",
            version="1.75",
            has_generics=True,
            has_async_await=True,
            has_pattern_matching=True,
            has_null_safety=True,
            has_memory_safety=True,
            has_type_inference=True,
            has_macros=True,
            has_traits_interfaces=True,
            concurrency_model="async",
            has_channels=True,
            error_handling="result_types",
            package_manager="cargo",
            package_file="Cargo.toml",
            build_system="cargo",
            build_file="Cargo.toml",
            web_frameworks=["axum", "warp", "rocket", "actix-web"],
            testing_frameworks=["built-in", "proptest", "criterion"],
            orm_libraries=["diesel", "sqlx", "sea-orm"]
        )
        super().__init__(features)
        
        self.type_mappings = {
            "string": "String",
            "str": "&str", 
            "int": "i32",
            "long": "i64",
            "float": "f32",
            "double": "f64",
            "boolean": "bool",
            "void": "()",
            "list": "Vec",
            "array": "Vec",
            "map": "HashMap",
            "dict": "HashMap",
            "set": "HashSet"
        }
        
        self.common_imports = {
            "web": ["tokio", "axum", "serde", "anyhow"],
            "cli": ["clap", "anyhow", "tokio"],
            "library": ["serde", "thiserror"],
            "service": ["tokio", "axum", "serde", "tracing", "anyhow"]
        }
    
    def generate_project_structure(self, context: CodeGenerationContext) -> Dict[str, str]:
        """Generate Rust project structure with Cargo.toml and main files"""
        
        # Determine project type and dependencies
        is_binary = context.domain in ["cli", "service"]
        dependencies = self._get_dependencies(context)
        
        cargo_toml = f'''[package]
name = "{self._sanitize_name(context.domain)}"
version = "0.1.0"
edition = "2021"
authors = ["Generated by MyndraComposer"]
description = "Modernized {context.source_language} to Rust migration"

[dependencies]
{self._format_dependencies(dependencies)}

[dev-dependencies]
tokio-test = "0.4"
criterion = "0.5"

[[bin]]
name = "{self._sanitize_name(context.domain)}"
path = "src/main.rs"

[[bench]]
name = "benchmarks"
harness = false
'''

        lib_rs = '''//! Main library module
//! Auto-generated Rust code from MyndraComposer

pub mod core;
pub mod error;
pub mod utils;

pub use error::{Result, Error};
'''

        main_rs = '''//! Main application entry point
//! Auto-generated Rust code from MyndraComposer

use anyhow::Result;
use tracing::{info, error};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::init();
    
    info!("Starting application...");
    
    match run().await {
        Ok(_) => {
            info!("Application completed successfully");
            Ok(())
        }
        Err(e) => {
            error!("Application error: {:?}", e);
            Err(e)
        }
    }
}

async fn run() -> Result<()> {
    // TODO: Implement main application logic
    println!("Hello from modernized Rust application!");
    Ok(())
}
'''

        error_rs = '''//! Error handling module
//! Demonstrates modern Rust error handling patterns

use thiserror::Error;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Parse error: {message}")]
    Parse { message: String },
    
    #[error("Configuration error: {0}")]
    Config(String),
    
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("Database error: {0}")]
    Database(String),
    
    #[error("Validation error: {field} - {message}")]
    Validation { field: String, message: String },
    
    #[error("Not found: {resource}")]
    NotFound { resource: String },
    
    #[error("Unauthorized access")]
    Unauthorized,
    
    #[error("Internal server error")]
    Internal,
}

impl Error {
    pub fn parse(message: impl Into<String>) -> Self {
        Error::Parse { message: message.into() }
    }
    
    pub fn config(message: impl Into<String>) -> Self {
        Error::Config(message.into())
    }
    
    pub fn database(message: impl Into<String>) -> Self {
        Error::Database(message.into())
    }
    
    pub fn validation(field: impl Into<String>, message: impl Into<String>) -> Self {
        Error::Validation { 
            field: field.into(), 
            message: message.into() 
        }
    }
    
    pub fn not_found(resource: impl Into<String>) -> Self {
        Error::NotFound { resource: resource.into() }
    }
}
'''

        utils_rs = '''//! Utility functions and helpers
//! Common utilities for the modernized application

use crate::Result;
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{info, warn, error};

/// Generate a unique ID based on timestamp
pub fn generate_id() -> String {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis();
    format!("id_{}", timestamp)
}

/// Validate email format using basic regex
pub fn validate_email(email: &str) -> bool {
    email.contains('@') && email.contains('.')
}

/// Retry function with exponential backoff
pub async fn retry_with_backoff<T, F, Fut>(
    mut operation: F,
    max_retries: u32,
    base_delay_ms: u64,
) -> Result<T>
where
    F: FnMut() -> Fut,
    Fut: std::future::Future<Output = Result<T>>,
{
    let mut delay = base_delay_ms;
    
    for attempt in 1..=max_retries {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempt == max_retries => {
                error!("Operation failed after {} attempts: {:?}", max_retries, e);
                return Err(e);
            }
            Err(e) => {
                warn!("Attempt {} failed, retrying in {}ms: {:?}", attempt, delay, e);
                tokio::time::sleep(std::time::Duration::from_millis(delay)).await;
                delay *= 2; // Exponential backoff
            }
        }
    }
    
    unreachable!()
}

/// Safe division that returns Option instead of panicking
pub fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}

/// Format bytes as human-readable string
pub fn format_bytes(bytes: u64) -> String {
    const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
    const THRESHOLD: f64 = 1024.0;
    
    if bytes == 0 {
        return "0 B".to_string();
    }
    
    let mut size = bytes as f64;
    let mut unit_index = 0;
    
    while size >= THRESHOLD && unit_index < UNITS.len() - 1 {
        size /= THRESHOLD;
        unit_index += 1;
    }
    
    format!("{:.1} {}", size, UNITS[unit_index])
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_validate_email() {
        assert!(validate_email("user@example.com"));
        assert!(validate_email("test.user@domain.co.uk"));
        assert!(!validate_email("invalid_email"));
        assert!(!validate_email("@domain.com"));
        assert!(!validate_email("user@"));
    }
    
    #[test]
    fn test_safe_divide() {
        assert_eq!(safe_divide(10.0, 2.0), Some(5.0));
        assert_eq!(safe_divide(10.0, 0.0), None);
        assert_eq!(safe_divide(-10.0, 2.0), Some(-5.0));
    }
    
    #[test]
    fn test_format_bytes() {
        assert_eq!(format_bytes(0), "0 B");
        assert_eq!(format_bytes(500), "500.0 B");
        assert_eq!(format_bytes(1024), "1.0 KB");
        assert_eq!(format_bytes(1536), "1.5 KB");
        assert_eq!(format_bytes(1048576), "1.0 MB");
    }
    
    #[tokio::test]
    async fn test_retry_with_backoff() {
        let mut attempts = 0;
        
        let result = retry_with_backoff(
            || {
                attempts += 1;
                async move {
                    if attempts < 3 {
                        Err(crate::Error::Internal)
                    } else {
                        Ok("success")
                    }
                }
            },
            5,
            10
        ).await;
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "success");
        assert_eq!(attempts, 3);
    }
}
'''

        core_rs = '''//! Core application logic
//! Main business logic and domain models

use crate::{Result, Error};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use tracing::{info, debug};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub app_name: String,
    pub version: String,
    pub environment: Environment,
    pub database_url: Option<String>,
    pub api_key: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Environment {
    Development,
    Testing,
    Production,
}

impl Config {
    pub fn load() -> Result<Self> {
        // In a real application, this would load from environment variables,
        // configuration files, etc.
        Ok(Config {
            app_name: "MyndraComposer Generated App".to_string(),
            version: "0.1.0".to_string(),
            environment: Environment::Development,
            database_url: std::env::var("DATABASE_URL").ok(),
            api_key: std::env::var("API_KEY").ok(),
        })
    }
    
    pub fn is_production(&self) -> bool {
        matches!(self.environment, Environment::Production)
    }
}

/// Generic repository trait for data access
#[async_trait::async_trait]
pub trait Repository<T, ID> {
    async fn find_by_id(&self, id: ID) -> Result<Option<T>>;
    async fn find_all(&self) -> Result<Vec<T>>;
    async fn save(&self, entity: T) -> Result<T>;
    async fn delete(&self, id: ID) -> Result<bool>;
}

/// Service layer for business logic
pub struct ApplicationService {
    config: Config,
    metrics: HashMap<String, u64>,
}

impl ApplicationService {
    pub fn new(config: Config) -> Self {
        Self {
            config,
            metrics: HashMap::new(),
        }
    }
    
    pub async fn initialize(&mut self) -> Result<()> {
        info!("Initializing application service");
        debug!("Config: {:?}", self.config);
        
        // Initialize any required resources
        self.metrics.insert("initialization_count".to_string(), 1);
        
        Ok(())
    }
    
    pub fn get_config(&self) -> &Config {
        &self.config
    }
    
    pub fn get_metrics(&self) -> &HashMap<String, u64> {
        &self.metrics
    }
    
    pub fn increment_metric(&mut self, key: &str) {
        let counter = self.metrics.entry(key.to_string()).or_insert(0);
        *counter += 1;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_config_load() {
        let config = Config::load().unwrap();
        assert_eq!(config.app_name, "MyndraComposer Generated App");
        assert_eq!(config.version, "0.1.0");
    }
    
    #[test]
    fn test_service_initialization() {
        let config = Config::load().unwrap();
        let mut service = ApplicationService::new(config);
        
        // Test initial state
        assert_eq!(service.get_metrics().len(), 0);
        
        // Test metric increment
        service.increment_metric("test_counter");
        assert_eq!(service.get_metrics().get("test_counter"), Some(&1));
    }
}
'''

        return {
            "Cargo.toml": cargo_toml,
            "src/lib.rs": lib_rs,
            "src/main.rs": main_rs,
            "src/error.rs": error_rs,
            "src/utils.rs": utils_rs,
            "src/core.rs": core_rs,
            ".gitignore": self._generate_gitignore(),
            "README.md": self._generate_readme(context),
        }
    
    def generate_function(self, function_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate a Rust function"""
        name = function_info.get("name", "unnamed_function")
        params = function_info.get("parameters", [])
        return_type = function_info.get("return_type", "void")
        is_async = function_info.get("is_async", False)
        visibility = function_info.get("visibility", "private")
        description = function_info.get("description", "")
        
        # Convert types
        rust_return_type = self._convert_type(return_type)
        if rust_return_type != "()" and not rust_return_type.startswith("Result"):
            rust_return_type = f"Result<{rust_return_type}>"
        
        # Generate parameters
        rust_params = []
        for param in params:
            param_name = param.get("name", "param")
            param_type = param.get("type", "String")
            rust_type = self._convert_type(param_type)
            
            # Use references for strings to be more idiomatic
            if rust_type == "String":
                rust_type = "&str"
            
            rust_params.append(f"{param_name}: {rust_type}")
        
        # Visibility
        vis = "pub " if visibility == "public" else ""
        
        # Async keyword
        async_kw = "async " if is_async else ""
        
        # Generate function signature
        params_str = ", ".join(rust_params)
        
        # Generate documentation
        doc = ""
        if description:
            doc = f"    /// {description}\n"
        
        # Generate function body
        body = self._generate_function_body(function_info, context)
        
        return f'''{doc}{vis}{async_kw}fn {name}({params_str}) -> {rust_return_type} {{
{body}
}}'''
    
    def generate_class(self, class_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate a Rust struct with implementation"""
        name = class_info.get("name", "UnnamedStruct")
        fields = class_info.get("fields", [])
        methods = class_info.get("methods", [])
        description = class_info.get("description", "")
        is_serializable = class_info.get("serializable", False)
        
        # Generate struct fields
        struct_fields = []
        for field in fields:
            field_name = field.get("name", "field")
            field_type = field.get("type", "String")
            field_vis = "pub " if field.get("visibility", "private") == "public" else ""
            rust_type = self._convert_type(field_type)
            
            struct_fields.append(f"    {field_vis}{field_name}: {rust_type},")
        
        # Derives
        derives = ["Debug", "Clone"]
        if is_serializable:
            derives.extend(["Serialize", "Deserialize"])
        
        derives_str = f"#[derive({', '.join(derives)})]"
        
        # Documentation
        doc = ""
        if description:
            doc = f"/// {description}\n"
        
        # Struct definition
        struct_def = f'''{doc}{derives_str}
pub struct {name} {{
{chr(10).join(struct_fields)}
}}'''
        
        # Implementation block
        impl_methods = []
        for method in methods:
            rust_method = self.generate_function(method, context)
            # Indent the method
            indented_method = "\n".join(f"    {line}" for line in rust_method.split("\n"))
            impl_methods.append(indented_method)
        
        # Constructor method
        constructor_params = []
        constructor_assignments = []
        for field in fields:
            field_name = field.get("name", "field")
            field_type = field.get("type", "String")
            rust_type = self._convert_type(field_type)
            
            if rust_type == "String":
                rust_type = "impl Into<String>"
                constructor_assignments.append(f"            {field_name}: {field_name}.into(),")
            else:
                constructor_assignments.append(f"            {field_name},")
            
            constructor_params.append(f"{field_name}: {rust_type}")
        
        constructor = f'''    /// Create a new instance of {name}
    pub fn new({", ".join(constructor_params)}) -> Self {{
        Self {{
{chr(10).join(constructor_assignments)}
        }}
    }}'''
        
        impl_block = f'''impl {name} {{
{constructor}

{chr(10).join(impl_methods)}
}}'''
        
        return f'''{struct_def}

{impl_block}'''
    
    def generate_module(self, module_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate a Rust module"""
        name = module_info.get("name", "unnamed_module")
        description = module_info.get("description", "")
        functions = module_info.get("functions", [])
        classes = module_info.get("classes", [])
        submodules = module_info.get("submodules", [])
        imports = module_info.get("imports", [])
        
        # Module header
        header = f'''//! {name} module
//! {description}

'''
        
        # Imports
        imports_section = ""
        if imports:
            rust_imports = []
            for imp in imports:
                rust_imports.append(f"use {self._convert_import(imp)};")
            imports_section = "\n".join(rust_imports) + "\n\n"
        
        # Submodules
        submodule_declarations = ""
        if submodules:
            for submod in submodules:
                submodule_declarations += f"pub mod {submod};\n"
            submodule_declarations += "\n"
        
        # Generate classes
        classes_section = ""
        for class_info in classes:
            classes_section += self.generate_class(class_info, context) + "\n\n"
        
        # Generate functions
        functions_section = ""
        for func_info in functions:
            functions_section += self.generate_function(func_info, context) + "\n\n"
        
        return header + imports_section + submodule_declarations + classes_section + functions_section
    
    def generate_error_handling(self, error_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate Rust error handling code"""
        error_type = error_info.get("type", "generic")
        message = error_info.get("message", "An error occurred")
        
        if error_type == "io":
            return f'std::io::Error::new(std::io::ErrorKind::Other, "{message}")'
        elif error_type == "parse":
            return f'Error::parse("{message}")'
        elif error_type == "validation":
            field = error_info.get("field", "unknown")
            return f'Error::validation("{field}", "{message}")'
        else:
            return f'Error::Internal'
    
    def generate_async_code(self, async_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate Rust async code"""
        operation = async_info.get("operation", "")
        
        if "http_request" in operation.lower():
            return '''let client = reqwest::Client::new();
let response = client.get(url)
    .send()
    .await?
    .json::<ResponseType>()
    .await?;'''
        elif "file_read" in operation.lower():
            return '''let contents = tokio::fs::read_to_string(path).await?;'''
        elif "database" in operation.lower():
            return '''let result = sqlx::query("SELECT * FROM table")
    .fetch_all(&pool)
    .await?;'''
        else:
            return '''// TODO: Implement async operation
tokio::time::sleep(std::time::Duration::from_millis(100)).await;'''
    
    def generate_tests(self, test_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate Rust test code"""
        test_name = test_info.get("name", "test_function")
        is_async = test_info.get("is_async", False)
        
        test_attr = "#[tokio::test]" if is_async else "#[test]"
        async_kw = "async " if is_async else ""
        
        return f'''{test_attr}
{async_kw}fn {test_name}() {{
    // TODO: Implement test
    assert!(true);
}}'''
    
    def get_migration_strategies(self, source_analysis: Dict[str, Any]) -> List[MigrationStrategy]:
        """Get Rust-specific migration strategies"""
        strategies = []
        
        # Memory safety focused migration
        strategies.append(MigrationStrategy(
            name="Memory Safety First",
            description="Prioritize memory safety and eliminate undefined behavior",
            approach="rewrite",
            complexity="high",
            timeline_estimate="3-6 months",
            risks=["Learning curve", "Performance optimization needed"],
            benefits=["Memory safety", "Thread safety", "Zero-cost abstractions"],
            prerequisites=["Team Rust training", "Architecture review"],
            requires_manual_review=True,
            supports_gradual_migration=False,
            maintains_performance=True,
            preserves_architecture=False
        ))
        
        # Incremental migration
        strategies.append(MigrationStrategy(
            name="Incremental Services Migration",
            description="Migrate service by service, starting with new features",
            approach="incremental",
            complexity="medium",
            timeline_estimate="6-12 months",
            risks=["API compatibility", "Deployment complexity"],
            benefits=["Reduced risk", "Gradual learning", "Immediate benefits"],
            prerequisites=["Service boundaries defined", "API contracts stable"],
            requires_manual_review=True,
            supports_gradual_migration=True,
            maintains_performance=True,
            preserves_architecture=True
        ))
        
        return strategies
    
    def get_best_practices(self, context: CodeGenerationContext) -> List[str]:
        """Get Rust best practices"""
        return [
            "Use Result<T, E> for error handling instead of panicking",
            "Prefer borrowing (&T) over owned types (T) in function parameters",
            "Use Vec<T> for growable arrays, [T; N] for fixed-size arrays",
            "Implement Display and Debug traits for custom types",
            "Use #[derive(Debug, Clone)] for most structs",
            "Prefer iterators over loops for functional programming",
            "Use async/await for I/O bound operations",
            "Group related functionality in modules with clear public APIs",
            "Write comprehensive tests with #[test] and #[cfg(test)]",
            "Use cargo fmt and cargo clippy for code quality"
        ]
    
    def _convert_type(self, original_type: str) -> str:
        """Convert generic type to Rust type"""
        if original_type in self.type_mappings:
            return self.type_mappings[original_type]
        
        # Handle generic types
        if original_type.startswith("List<") or original_type.startswith("list<"):
            inner_type = original_type[5:-1]
            return f"Vec<{self._convert_type(inner_type)}>"
        elif original_type.startswith("Map<") or original_type.startswith("map<"):
            # Extract key and value types
            inner = original_type[4:-1]
            if "," in inner:
                key_type, value_type = inner.split(",", 1)
                return f"HashMap<{self._convert_type(key_type.strip())}, {self._convert_type(value_type.strip())}>"
        
        # Default to String for unknown types
        return "String"
    
    def _convert_import(self, import_statement: str) -> str:
        """Convert import statement to Rust use statement"""
        # This is a simplified conversion - real implementation would be more sophisticated
        if "http" in import_statement.lower():
            return "reqwest"
        elif "json" in import_statement.lower():
            return "serde_json"
        elif "datetime" in import_statement.lower():
            return "chrono::{DateTime, Utc}"
        else:
            return import_statement.replace(".", "::")
    
    def _get_dependencies(self, context: CodeGenerationContext) -> Dict[str, str]:
        """Get dependencies based on context"""
        base_deps = {
            "tokio": '{ version = "1.0", features = ["full"] }',
            "anyhow": '"1.0"',
            "thiserror": '"1.0"',
            "tracing": '"0.1"',
            "tracing-subscriber": '"0.3"',
            "serde": '{ version = "1.0", features = ["derive"] }',
            "serde_json": '"1.0"',
        }
        
        if context.domain == "web":
            base_deps.update({
                "axum": '"0.7"',
                "reqwest": '{ version = "0.11", features = ["json"] }',
                "tower": '"0.4"',
                "tower-http": '{ version = "0.5", features = ["cors"] }',
            })
        
        if context.domain == "cli":
            base_deps.update({
                "clap": '{ version = "4.0", features = ["derive"] }',
            })
        
        if "database" in context.domain.lower():
            base_deps.update({
                "sqlx": '{ version = "0.7", features = ["runtime-tokio-rustls", "postgres"] }',
            })
        
        return base_deps
    
    def _format_dependencies(self, deps: Dict[str, str]) -> str:
        """Format dependencies for Cargo.toml"""
        lines = []
        for name, version in deps.items():
            lines.append(f"{name} = {version}")
        return "\n".join(lines)
    
    def _sanitize_name(self, name: str) -> str:
        """Sanitize name for Rust package naming conventions"""
        return name.lower().replace(" ", "_").replace("-", "_")
    
    def _generate_function_body(self, function_info: Dict[str, Any], context: CodeGenerationContext) -> str:
        """Generate function body based on function info"""
        # This is a placeholder - real implementation would analyze the function
        # and generate appropriate Rust code
        return '''    // TODO: Implement function logic
    Ok(())'''
    
    def _generate_gitignore(self) -> str:
        """Generate .gitignore for Rust project"""
        return '''/target/
**/*.rs.bk
Cargo.lock
.env
.vscode/
.idea/
*.swp
*.tmp
'''
    
    def _generate_readme(self, context: CodeGenerationContext) -> str:
        """Generate README.md for Rust project"""
        return f'''# {context.domain.title()} - Rust Migration

This project was generated by MyndraComposer, migrating from {context.source_language} to Rust.

## Features

- Memory-safe systems programming
- Zero-cost abstractions
- Thread-safe concurrency
- Modern error handling with Result types
- Comprehensive testing

## Getting Started

### Prerequisites

- Rust 1.75 or later
- Cargo (included with Rust)

### Building

```bash
cargo build
```

### Running

```bash
cargo run
```

### Testing

```bash
cargo test
```

### Formatting and Linting

```bash
cargo fmt
cargo clippy
```

## Project Structure

- `src/main.rs` - Application entry point
- `src/lib.rs` - Library root
- `src/core.rs` - Core business logic
- `src/error.rs` - Error handling
- `src/utils.rs` - Utility functions

## Generated by

MyndraComposer - Universal Code Modernization Platform
Generated on: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
'''