"""
Security Vulnerability Scanner for MyndraComposer
Provides comprehensive security analysis and vulnerability detection
"""

import os
import json
import subprocess
import asyncio
import re
import hashlib
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path
from datetime import datetime
from enum import Enum
import tempfile


class SeverityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityCategory(Enum):
    INJECTION = "injection"
    BROKEN_AUTH = "broken_authentication"
    SENSITIVE_DATA = "sensitive_data_exposure"
    XXE = "xml_external_entities"
    BROKEN_ACCESS = "broken_access_control"
    SECURITY_MISCONFIG = "security_misconfiguration"
    XSS = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    VULNERABLE_COMPONENTS = "vulnerable_components"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    CRYPTOGRAPHIC_FAILURES = "cryptographic_failures"
    SSRF = "server_side_request_forgery"


@dataclass
class SecurityVulnerability:
    """Represents a security vulnerability"""
    id: str
    title: str
    description: str
    severity: SeverityLevel
    category: VulnerabilityCategory
    file_path: str
    line_number: Optional[int] = None
    column_number: Optional[int] = None
    code_snippet: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation: Optional[str] = None
    references: List[str] = None
    false_positive: bool = False
    
    def __post_init__(self):
        if self.references is None:
            self.references = []


@dataclass
class SecurityScanResult:
    """Results from a security scan"""
    scan_id: str
    timestamp: str
    total_files_scanned: int
    vulnerabilities: List[SecurityVulnerability]
    scan_duration_seconds: float
    tools_used: List[str]
    summary: Dict[str, Any]
    success: bool
    error_details: Optional[str] = None


class StaticAnalysisEngine:
    """Static analysis engine for detecting security vulnerabilities"""
    
    def __init__(self):
        self.patterns = self._load_vulnerability_patterns()
        self.dangerous_functions = self._load_dangerous_functions()
        self.crypto_patterns = self._load_crypto_patterns()
    
    def _load_vulnerability_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load vulnerability detection patterns"""
        return {
            "sql_injection": [
                {
                    "pattern": r"(?i)(?:execute|exec|query|prepare)\s*\(\s*[\"'].*?\+.*?[\"']\s*\)",
                    "severity": SeverityLevel.HIGH,
                    "category": VulnerabilityCategory.INJECTION,
                    "description": "Potential SQL injection vulnerability detected"
                },
                {
                    "pattern": r"(?i)(?:SELECT|INSERT|UPDATE|DELETE|DROP|CREATE).*?\+.*?(?:WHERE|VALUES|SET)",
                    "severity": SeverityLevel.HIGH,
                    "category": VulnerabilityCategory.INJECTION,
                    "description": "SQL query construction with string concatenation"
                }
            ],
            "command_injection": [
                {
                    "pattern": r"(?:system|exec|shell_exec|passthru|eval)\s*\(\s*.*?\$.*?\)",
                    "severity": SeverityLevel.CRITICAL,
                    "category": VulnerabilityCategory.INJECTION,
                    "description": "Command injection vulnerability detected"
                },
                {
                    "pattern": r"subprocess\.(?:call|run|Popen)\s*\(\s*.*?\+.*?\)",
                    "severity": SeverityLevel.HIGH,
                    "category": VulnerabilityCategory.INJECTION,
                    "description": "Potential command injection in subprocess call"
                }
            ],
            "xss": [
                {
                    "pattern": r"innerHTML\s*=\s*.*?\+.*?",
                    "severity": SeverityLevel.MEDIUM,
                    "category": VulnerabilityCategory.XSS,
                    "description": "Potential XSS vulnerability with innerHTML"
                },
                {
                    "pattern": r"document\.write\s*\(\s*.*?\+.*?\)",
                    "severity": SeverityLevel.MEDIUM,
                    "category": VulnerabilityCategory.XSS,
                    "description": "Potential XSS vulnerability with document.write"
                }
            ],
            "hardcoded_secrets": [
                {
                    "pattern": r"(?i)(?:password|passwd|pwd|secret|token|key|api[_-]?key)\s*[=:]\s*[\"'][^\"']{8,}[\"']",
                    "severity": SeverityLevel.HIGH,
                    "category": VulnerabilityCategory.SENSITIVE_DATA,
                    "description": "Hardcoded secret or credential detected"
                },
                {
                    "pattern": r"(?i)(?:aws|amazon)[_-]?(?:access[_-]?key|secret[_-]?key|session[_-]?token)",
                    "severity": SeverityLevel.CRITICAL,
                    "category": VulnerabilityCategory.SENSITIVE_DATA,
                    "description": "AWS credentials detected"
                }
            ],
            "weak_crypto": [
                {
                    "pattern": r"(?i)(?:md5|sha1|des|rc4)\s*\(",
                    "severity": SeverityLevel.MEDIUM,
                    "category": VulnerabilityCategory.CRYPTOGRAPHIC_FAILURES,
                    "description": "Weak cryptographic algorithm detected"
                },
                {
                    "pattern": r"(?i)random\.random\(\)",
                    "severity": SeverityLevel.LOW,
                    "category": VulnerabilityCategory.CRYPTOGRAPHIC_FAILURES,
                    "description": "Weak random number generation"
                }
            ],
            "path_traversal": [
                {
                    "pattern": r"(?:open|file|read)\s*\(\s*.*?\+.*?\.\..*?\)",
                    "severity": SeverityLevel.HIGH,
                    "category": VulnerabilityCategory.BROKEN_ACCESS,
                    "description": "Potential path traversal vulnerability"
                }
            ]
        }
    
    def _load_dangerous_functions(self) -> Dict[str, Dict[str, Any]]:
        """Load list of dangerous functions by language"""
        return {
            "python": {
                "eval": {"severity": SeverityLevel.CRITICAL, "description": "Code injection risk"},
                "exec": {"severity": SeverityLevel.CRITICAL, "description": "Code injection risk"},
                "compile": {"severity": SeverityLevel.HIGH, "description": "Dynamic code compilation"},
                "os.system": {"severity": SeverityLevel.HIGH, "description": "Command injection risk"},
                "subprocess.call": {"severity": SeverityLevel.MEDIUM, "description": "Potential command injection"},
                "pickle.loads": {"severity": SeverityLevel.HIGH, "description": "Insecure deserialization"},
                "yaml.load": {"severity": SeverityLevel.HIGH, "description": "Insecure YAML deserialization"}
            },
            "javascript": {
                "eval": {"severity": SeverityLevel.CRITICAL, "description": "Code injection risk"},
                "Function": {"severity": SeverityLevel.HIGH, "description": "Dynamic function creation"},
                "setTimeout": {"severity": SeverityLevel.MEDIUM, "description": "Potential code injection"},
                "setInterval": {"severity": SeverityLevel.MEDIUM, "description": "Potential code injection"},
                "innerHTML": {"severity": SeverityLevel.MEDIUM, "description": "XSS risk"},
                "document.write": {"severity": SeverityLevel.MEDIUM, "description": "XSS risk"}
            },
            "java": {
                "Runtime.exec": {"severity": SeverityLevel.HIGH, "description": "Command injection risk"},
                "ProcessBuilder": {"severity": SeverityLevel.MEDIUM, "description": "Potential command injection"},
                "ObjectInputStream.readObject": {"severity": SeverityLevel.HIGH, "description": "Insecure deserialization"},
                "ScriptEngine.eval": {"severity": SeverityLevel.CRITICAL, "description": "Code injection risk"}
            },
            "c": {
                "gets": {"severity": SeverityLevel.CRITICAL, "description": "Buffer overflow risk"},
                "strcpy": {"severity": SeverityLevel.HIGH, "description": "Buffer overflow risk"},
                "strcat": {"severity": SeverityLevel.HIGH, "description": "Buffer overflow risk"},
                "sprintf": {"severity": SeverityLevel.HIGH, "description": "Buffer overflow risk"},
                "system": {"severity": SeverityLevel.HIGH, "description": "Command injection risk"}
            }
        }
    
    def _load_crypto_patterns(self) -> List[Dict[str, Any]]:
        """Load cryptographic vulnerability patterns"""
        return [
            {
                "pattern": r"(?i)(?:DES|3DES|RC4|MD5|SHA1)",
                "severity": SeverityLevel.MEDIUM,
                "description": "Weak cryptographic algorithm"
            },
            {
                "pattern": r"(?i)(?:password|key)\s*=\s*[\"'].{1,7}[\"']",
                "severity": SeverityLevel.HIGH,
                "description": "Weak password or key"
            },
            {
                "pattern": r"(?i)ssl[_-]?verify\s*=\s*(?:false|0|off)",
                "severity": SeverityLevel.HIGH,
                "description": "SSL verification disabled"
            }
        ]
    
    async def scan_file(self, file_path: Path, language: str = None) -> List[SecurityVulnerability]:
        """Scan a single file for security vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            # Pattern-based scanning
            vulnerabilities.extend(
                await self._scan_patterns(file_path, content, lines)
            )
            
            # Language-specific dangerous function scanning
            if language:
                vulnerabilities.extend(
                    await self._scan_dangerous_functions(file_path, content, lines, language)
                )
            
            # Cryptographic vulnerability scanning
            vulnerabilities.extend(
                await self._scan_crypto_vulnerabilities(file_path, content, lines)
            )
            
        except Exception as e:
            # Log error but don't fail the entire scan
            print(f"Warning: Failed to scan {file_path}: {e}")
        
        return vulnerabilities
    
    async def _scan_patterns(self, file_path: Path, content: str, lines: List[str]) -> List[SecurityVulnerability]:
        """Scan for pattern-based vulnerabilities"""
        vulnerabilities = []
        
        for category, patterns in self.patterns.items():
            for pattern_def in patterns:
                pattern = pattern_def["pattern"]
                
                for match in re.finditer(pattern, content, re.MULTILINE):
                    line_num = content[:match.start()].count('\n') + 1
                    
                    # Get code snippet
                    if line_num <= len(lines):
                        code_snippet = lines[line_num - 1].strip()
                    else:
                        code_snippet = match.group(0)
                    
                    vulnerability = SecurityVulnerability(
                        id=self._generate_vuln_id(file_path, line_num, pattern),
                        title=f"{category.replace('_', ' ').title()} Vulnerability",
                        description=pattern_def["description"],
                        severity=pattern_def["severity"],
                        category=pattern_def["category"],
                        file_path=str(file_path),
                        line_number=line_num,
                        code_snippet=code_snippet,
                        remediation=self._get_remediation(pattern_def["category"])
                    )
                    
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _scan_dangerous_functions(
        self, 
        file_path: Path, 
        content: str, 
        lines: List[str], 
        language: str
    ) -> List[SecurityVulnerability]:
        """Scan for dangerous function usage"""
        vulnerabilities = []
        
        dangerous_funcs = self.dangerous_functions.get(language.lower(), {})
        
        for func_name, func_info in dangerous_funcs.items():
            pattern = rf"\b{re.escape(func_name)}\s*\("
            
            for match in re.finditer(pattern, content):
                line_num = content[:match.start()].count('\n') + 1
                
                if line_num <= len(lines):
                    code_snippet = lines[line_num - 1].strip()
                else:
                    code_snippet = match.group(0)
                
                vulnerability = SecurityVulnerability(
                    id=self._generate_vuln_id(file_path, line_num, func_name),
                    title=f"Dangerous Function: {func_name}",
                    description=func_info["description"],
                    severity=func_info["severity"],
                    category=VulnerabilityCategory.INJECTION,  # Default category
                    file_path=str(file_path),
                    line_number=line_num,
                    code_snippet=code_snippet,
                    remediation=f"Consider using safer alternatives to {func_name}"
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _scan_crypto_vulnerabilities(
        self, 
        file_path: Path, 
        content: str, 
        lines: List[str]
    ) -> List[SecurityVulnerability]:
        """Scan for cryptographic vulnerabilities"""
        vulnerabilities = []
        
        for crypto_pattern in self.crypto_patterns:
            pattern = crypto_pattern["pattern"]
            
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count('\n') + 1
                
                if line_num <= len(lines):
                    code_snippet = lines[line_num - 1].strip()
                else:
                    code_snippet = match.group(0)
                
                vulnerability = SecurityVulnerability(
                    id=self._generate_vuln_id(file_path, line_num, "crypto"),
                    title="Cryptographic Vulnerability",
                    description=crypto_pattern["description"],
                    severity=crypto_pattern["severity"],
                    category=VulnerabilityCategory.CRYPTOGRAPHIC_FAILURES,
                    file_path=str(file_path),
                    line_number=line_num,
                    code_snippet=code_snippet,
                    remediation="Use modern, secure cryptographic algorithms"
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _generate_vuln_id(self, file_path: Path, line_num: int, context: str) -> str:
        """Generate unique vulnerability ID"""
        content = f"{file_path}:{line_num}:{context}"
        return hashlib.md5(content.encode()).hexdigest()[:12]
    
    def _get_remediation(self, category: VulnerabilityCategory) -> str:
        """Get remediation advice for vulnerability category"""
        remediations = {
            VulnerabilityCategory.INJECTION: "Use parameterized queries and input validation",
            VulnerabilityCategory.XSS: "Sanitize and escape user input before output",
            VulnerabilityCategory.SENSITIVE_DATA: "Use environment variables or secure vaults for secrets",
            VulnerabilityCategory.CRYPTOGRAPHIC_FAILURES: "Use modern, secure cryptographic algorithms",
            VulnerabilityCategory.BROKEN_ACCESS: "Implement proper access controls and path validation"
        }
        return remediations.get(category, "Review code for security best practices")


class ExternalToolScanner:
    """Integration with external security scanning tools"""
    
    def __init__(self):
        self.available_tools = self._detect_available_tools()
    
    def _detect_available_tools(self) -> Dict[str, bool]:
        """Detect which external security tools are available"""
        tools = {
            "semgrep": self._check_tool_available("semgrep"),
            "bandit": self._check_tool_available("bandit"),
            "safety": self._check_tool_available("safety"),
            "npm_audit": self._check_tool_available("npm"),
            "cargo_audit": self._check_tool_available("cargo-audit"),
            "gosec": self._check_tool_available("gosec"),
            "trivy": self._check_tool_available("trivy"),
            "snyk": self._check_tool_available("snyk")
        }
        return tools
    
    def _check_tool_available(self, tool_name: str) -> bool:
        """Check if a security tool is available"""
        try:
            result = subprocess.run(
                [tool_name, "--help"], 
                capture_output=True, 
                timeout=10
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
    
    async def run_semgrep(self, target_path: str) -> List[SecurityVulnerability]:
        """Run Semgrep security analysis"""
        if not self.available_tools.get("semgrep"):
            return []
        
        try:
            cmd = [
                "semgrep", 
                "--config=auto", 
                "--json", 
                "--quiet",
                target_path
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0:
                return self._parse_semgrep_output(stdout.decode())
            else:
                print(f"Semgrep failed: {stderr.decode()}")
                
        except Exception as e:
            print(f"Error running Semgrep: {e}")
        
        return []
    
    def _parse_semgrep_output(self, output: str) -> List[SecurityVulnerability]:
        """Parse Semgrep JSON output"""
        vulnerabilities = []
        
        try:
            data = json.loads(output)
            
            for result in data.get("results", []):
                severity_map = {
                    "ERROR": SeverityLevel.HIGH,
                    "WARNING": SeverityLevel.MEDIUM,
                    "INFO": SeverityLevel.LOW
                }
                
                vulnerability = SecurityVulnerability(
                    id=result.get("check_id", "semgrep-unknown"),
                    title=result.get("message", "Semgrep Finding"),
                    description=result.get("message", "Security issue detected by Semgrep"),
                    severity=severity_map.get(result.get("severity", "INFO"), SeverityLevel.INFO),
                    category=VulnerabilityCategory.VULNERABLE_COMPONENTS,  # Default
                    file_path=result.get("path", ""),
                    line_number=result.get("start", {}).get("line"),
                    code_snippet=result.get("extra", {}).get("lines", ""),
                    references=[result.get("check_id", "")]
                )
                
                vulnerabilities.append(vulnerability)
                
        except json.JSONDecodeError as e:
            print(f"Failed to parse Semgrep output: {e}")
        
        return vulnerabilities
    
    async def run_bandit(self, target_path: str) -> List[SecurityVulnerability]:
        """Run Bandit Python security analysis"""
        if not self.available_tools.get("bandit"):
            return []
        
        try:
            cmd = [
                "bandit", 
                "-r", 
                "-f", "json",
                target_path
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            # Bandit returns non-zero when issues found, which is expected
            if stdout:
                return self._parse_bandit_output(stdout.decode())
                
        except Exception as e:
            print(f"Error running Bandit: {e}")
        
        return []
    
    def _parse_bandit_output(self, output: str) -> List[SecurityVulnerability]:
        """Parse Bandit JSON output"""
        vulnerabilities = []
        
        try:
            data = json.loads(output)
            
            for result in data.get("results", []):
                severity_map = {
                    "HIGH": SeverityLevel.HIGH,
                    "MEDIUM": SeverityLevel.MEDIUM,
                    "LOW": SeverityLevel.LOW
                }
                
                vulnerability = SecurityVulnerability(
                    id=result.get("test_id", "bandit-unknown"),
                    title=result.get("test_name", "Bandit Finding"),
                    description=result.get("issue_text", "Security issue detected by Bandit"),
                    severity=severity_map.get(result.get("issue_severity", "LOW"), SeverityLevel.LOW),
                    category=VulnerabilityCategory.VULNERABLE_COMPONENTS,
                    file_path=result.get("filename", ""),
                    line_number=result.get("line_number"),
                    code_snippet=result.get("code", ""),
                    cwe_id=result.get("more_info", "")
                )
                
                vulnerabilities.append(vulnerability)
                
        except json.JSONDecodeError as e:
            print(f"Failed to parse Bandit output: {e}")
        
        return vulnerabilities
    
    async def run_npm_audit(self, target_path: str) -> List[SecurityVulnerability]:
        """Run npm audit for Node.js dependencies"""
        if not self.available_tools.get("npm_audit"):
            return []
        
        package_json = Path(target_path) / "package.json"
        if not package_json.exists():
            return []
        
        try:
            cmd = ["npm", "audit", "--json"]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=target_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if stdout:
                return self._parse_npm_audit_output(stdout.decode())
                
        except Exception as e:
            print(f"Error running npm audit: {e}")
        
        return []
    
    def _parse_npm_audit_output(self, output: str) -> List[SecurityVulnerability]:
        """Parse npm audit JSON output"""
        vulnerabilities = []
        
        try:
            data = json.loads(output)
            
            for vuln_id, vuln_info in data.get("vulnerabilities", {}).items():
                severity_map = {
                    "critical": SeverityLevel.CRITICAL,
                    "high": SeverityLevel.HIGH,
                    "moderate": SeverityLevel.MEDIUM,
                    "low": SeverityLevel.LOW,
                    "info": SeverityLevel.INFO
                }
                
                vulnerability = SecurityVulnerability(
                    id=vuln_id,
                    title=vuln_info.get("title", "npm audit finding"),
                    description=vuln_info.get("overview", "Vulnerability in npm dependency"),
                    severity=severity_map.get(vuln_info.get("severity", "info"), SeverityLevel.INFO),
                    category=VulnerabilityCategory.VULNERABLE_COMPONENTS,
                    file_path="package.json",
                    references=[vuln_info.get("url", "")]
                )
                
                vulnerabilities.append(vulnerability)
                
        except json.JSONDecodeError as e:
            print(f"Failed to parse npm audit output: {e}")
        
        return vulnerabilities


class SecurityScanner:
    """Main security scanner class"""
    
    def __init__(self, results_dir: str = None):
        self.results_dir = Path(results_dir) if results_dir else Path.cwd() / ".pomuse" / "security"
        self.results_dir.mkdir(parents=True, exist_ok=True)
        
        self.static_analyzer = StaticAnalysisEngine()
        self.external_scanner = ExternalToolScanner()
        
        self.language_map = {
            ".py": "python",
            ".js": "javascript",
            ".ts": "typescript",
            ".java": "java",
            ".c": "c",
            ".cpp": "c",
            ".h": "c",
            ".rs": "rust",
            ".go": "go",
            ".php": "php",
            ".rb": "ruby"
        }
    
    async def scan_project(self, project_path: str, include_external: bool = True) -> SecurityScanResult:
        """Perform comprehensive security scan of a project"""
        start_time = datetime.now()
        scan_id = f"scan_{start_time.strftime('%Y%m%d_%H%M%S')}"
        
        print(f"🔒 Starting security scan: {scan_id}")
        print(f"   Target: {project_path}")
        
        try:
            vulnerabilities = []
            tools_used = ["static_analysis"]
            
            # Static analysis scan
            print("   Running static analysis...")
            static_vulns = await self._scan_static_analysis(project_path)
            vulnerabilities.extend(static_vulns)
            
            # External tool scans
            if include_external:
                print("   Running external security tools...")
                
                # Semgrep
                if self.external_scanner.available_tools.get("semgrep"):
                    print("     - Running Semgrep...")
                    semgrep_vulns = await self.external_scanner.run_semgrep(project_path)
                    vulnerabilities.extend(semgrep_vulns)
                    tools_used.append("semgrep")
                
                # Bandit (Python)
                if self.external_scanner.available_tools.get("bandit"):
                    print("     - Running Bandit...")
                    bandit_vulns = await self.external_scanner.run_bandit(project_path)
                    vulnerabilities.extend(bandit_vulns)
                    tools_used.append("bandit")
                
                # npm audit (Node.js)
                if self.external_scanner.available_tools.get("npm_audit"):
                    print("     - Running npm audit...")
                    npm_vulns = await self.external_scanner.run_npm_audit(project_path)
                    vulnerabilities.extend(npm_vulns)
                    tools_used.append("npm_audit")
            
            # Remove duplicates
            vulnerabilities = self._deduplicate_vulnerabilities(vulnerabilities)
            
            # Calculate summary
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            # Count files scanned
            files_scanned = self._count_source_files(project_path)
            
            summary = self._calculate_summary(vulnerabilities)
            
            result = SecurityScanResult(
                scan_id=scan_id,
                timestamp=start_time.isoformat(),
                total_files_scanned=files_scanned,
                vulnerabilities=vulnerabilities,
                scan_duration_seconds=duration,
                tools_used=tools_used,
                summary=summary,
                success=True
            )
            
            # Save results
            await self._save_scan_result(result)
            
            print(f"✅ Security scan completed!")
            print(f"   Found {len(vulnerabilities)} vulnerabilities")
            print(f"   Scanned {files_scanned} files in {duration:.2f}s")
            
            return result
            
        except Exception as e:
            error_result = SecurityScanResult(
                scan_id=scan_id,
                timestamp=start_time.isoformat(),
                total_files_scanned=0,
                vulnerabilities=[],
                scan_duration_seconds=0,
                tools_used=[],
                summary={},
                success=False,
                error_details=str(e)
            )
            
            print(f"❌ Security scan failed: {e}")
            return error_result
    
    async def _scan_static_analysis(self, project_path: str) -> List[SecurityVulnerability]:
        """Run static analysis on all source files"""
        vulnerabilities = []
        project_path = Path(project_path)
        
        # Find all source files
        source_files = []
        for ext in self.language_map.keys():
            source_files.extend(project_path.rglob(f"*{ext}"))
        
        # Scan each file
        for file_path in source_files:
            language = self.language_map.get(file_path.suffix.lower())
            file_vulns = await self.static_analyzer.scan_file(file_path, language)
            vulnerabilities.extend(file_vulns)
        
        return vulnerabilities
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[SecurityVulnerability]) -> List[SecurityVulnerability]:
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            # Create a signature for deduplication
            signature = f"{vuln.file_path}:{vuln.line_number}:{vuln.category.value}:{vuln.title}"
            
            if signature not in seen:
                seen.add(signature)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def _count_source_files(self, project_path: str) -> int:
        """Count source files in project"""
        project_path = Path(project_path)
        count = 0
        
        for ext in self.language_map.keys():
            count += len(list(project_path.rglob(f"*{ext}")))
        
        return count
    
    def _calculate_summary(self, vulnerabilities: List[SecurityVulnerability]) -> Dict[str, Any]:
        """Calculate scan summary statistics"""
        if not vulnerabilities:
            return {
                "total_vulnerabilities": 0,
                "by_severity": {},
                "by_category": {},
                "risk_score": 0
            }
        
        # Count by severity
        by_severity = {}
        for vuln in vulnerabilities:
            severity = vuln.severity.value
            by_severity[severity] = by_severity.get(severity, 0) + 1
        
        # Count by category
        by_category = {}
        for vuln in vulnerabilities:
            category = vuln.category.value
            by_category[category] = by_category.get(category, 0) + 1
        
        # Calculate risk score (weighted by severity)
        severity_weights = {
            SeverityLevel.CRITICAL: 10,
            SeverityLevel.HIGH: 7,
            SeverityLevel.MEDIUM: 4,
            SeverityLevel.LOW: 2,
            SeverityLevel.INFO: 1
        }
        
        risk_score = sum(
            severity_weights.get(vuln.severity, 1) 
            for vuln in vulnerabilities
        )
        
        return {
            "total_vulnerabilities": len(vulnerabilities),
            "by_severity": by_severity,
            "by_category": by_category,
            "risk_score": risk_score,
            "files_affected": len(set(vuln.file_path for vuln in vulnerabilities))
        }
    
    async def _save_scan_result(self, result: SecurityScanResult):
        """Save scan results to file"""
        filename = f"{result.scan_id}.json"
        filepath = self.results_dir / filename
        
        # Convert to serializable format
        result_dict = {
            "scan_id": result.scan_id,
            "timestamp": result.timestamp,
            "total_files_scanned": result.total_files_scanned,
            "vulnerabilities": [asdict(vuln) for vuln in result.vulnerabilities],
            "scan_duration_seconds": result.scan_duration_seconds,
            "tools_used": result.tools_used,
            "summary": result.summary,
            "success": result.success,
            "error_details": result.error_details
        }
        
        # Convert enums to strings
        for vuln in result_dict["vulnerabilities"]:
            vuln["severity"] = vuln["severity"].value if hasattr(vuln["severity"], "value") else vuln["severity"]
            vuln["category"] = vuln["category"].value if hasattr(vuln["category"], "value") else vuln["category"]
        
        with open(filepath, 'w') as f:
            json.dump(result_dict, f, indent=2)
        
        print(f"📁 Security scan results saved to: {filepath}")
    
    def load_scan_results(self, scan_id: str = None) -> List[SecurityScanResult]:
        """Load previous scan results"""
        results = []
        
        pattern = f"{scan_id}.json" if scan_id else "*.json"
        
        for result_file in self.results_dir.glob(pattern):
            try:
                with open(result_file, 'r') as f:
                    data = json.load(f)
                
                # Convert back to objects
                vulnerabilities = []
                for vuln_data in data.get("vulnerabilities", []):
                    vuln_data["severity"] = SeverityLevel(vuln_data["severity"])
                    vuln_data["category"] = VulnerabilityCategory(vuln_data["category"])
                    vulnerabilities.append(SecurityVulnerability(**vuln_data))
                
                result = SecurityScanResult(
                    scan_id=data["scan_id"],
                    timestamp=data["timestamp"],
                    total_files_scanned=data["total_files_scanned"],
                    vulnerabilities=vulnerabilities,
                    scan_duration_seconds=data["scan_duration_seconds"],
                    tools_used=data["tools_used"],
                    summary=data["summary"],
                    success=data["success"],
                    error_details=data.get("error_details")
                )
                
                results.append(result)
                
            except Exception as e:
                print(f"Warning: Could not load {result_file}: {e}")
        
        return sorted(results, key=lambda x: x.timestamp, reverse=True)
    
    def generate_security_report(self, days: int = 30) -> Dict[str, Any]:
        """Generate security report for recent scans"""
        results = self.load_scan_results()
        
        # Filter recent results
        from datetime import timedelta
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_results = [
            r for r in results 
            if datetime.fromisoformat(r.timestamp) > cutoff_date
        ]
        
        if not recent_results:
            return {"error": f"No security scans found in the last {days} days"}
        
        # Aggregate data
        total_vulns = sum(len(r.vulnerabilities) for r in recent_results)
        total_files_scanned = sum(r.total_files_scanned for r in recent_results)
        
        # Severity breakdown
        severity_counts = {}
        category_counts = {}
        
        for result in recent_results:
            for vuln in result.vulnerabilities:
                severity = vuln.severity.value
                category = vuln.category.value
                
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
                category_counts[category] = category_counts.get(category, 0) + 1
        
        # Risk trend analysis
        risk_trend = []
        for result in recent_results:
            risk_trend.append({
                "date": result.timestamp[:10],  # Just the date part
                "risk_score": result.summary.get("risk_score", 0),
                "vulnerability_count": len(result.vulnerabilities)
            })
        
        return {
            "period": f"Last {days} days",
            "total_scans": len(recent_results),
            "total_vulnerabilities": total_vulns,
            "total_files_scanned": total_files_scanned,
            "severity_breakdown": severity_counts,
            "category_breakdown": category_counts,
            "risk_trend": sorted(risk_trend, key=lambda x: x["date"]),
            "recommendations": self._generate_security_recommendations(recent_results)
        }
    
    def _generate_security_recommendations(self, results: List[SecurityScanResult]) -> List[str]:
        """Generate security improvement recommendations"""
        recommendations = []
        
        if not results:
            return recommendations
        
        # Analyze vulnerability patterns
        all_vulns = []
        for result in results:
            all_vulns.extend(result.vulnerabilities)
        
        if not all_vulns:
            recommendations.append("✅ No vulnerabilities detected in recent scans!")
            return recommendations
        
        # Check for critical vulnerabilities
        critical_vulns = [v for v in all_vulns if v.severity == SeverityLevel.CRITICAL]
        if critical_vulns:
            recommendations.append(
                f"🚨 {len(critical_vulns)} critical vulnerabilities require immediate attention"
            )
        
        # Check for common vulnerability types
        vuln_categories = {}
        for vuln in all_vulns:
            category = vuln.category.value
            vuln_categories[category] = vuln_categories.get(category, 0) + 1
        
        # Top 3 most common categories
        top_categories = sorted(vuln_categories.items(), key=lambda x: x[1], reverse=True)[:3]
        
        for category, count in top_categories:
            if count > 2:  # Only recommend if significant
                category_name = category.replace('_', ' ').title()
                recommendations.append(
                    f"🔍 {count} {category_name} vulnerabilities detected. "
                    f"Consider implementing specific controls for this category."
                )
        
        # Security tool recommendations
        external_scanner = ExternalToolScanner()
        missing_tools = [
            tool for tool, available in external_scanner.available_tools.items() 
            if not available
        ]
        
        if missing_tools:
            recommendations.append(
                f"🛠️  Consider installing additional security tools: {', '.join(missing_tools[:3])}"
            )
        
        return recommendations


if __name__ == "__main__":
    async def main():
        scanner = SecurityScanner()
        
        # Example scan
        result = await scanner.scan_project(".", include_external=True)
        
        if result.success:
            print(f"\nScan Summary:")
            print(f"  Vulnerabilities: {len(result.vulnerabilities)}")
            print(f"  Risk Score: {result.summary.get('risk_score', 0)}")
        else:
            print(f"Scan failed: {result.error_details}")
    
    asyncio.run(main())